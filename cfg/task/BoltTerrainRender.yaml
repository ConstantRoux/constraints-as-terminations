# used to create the object
name: BoltTerrainRender
video_save_path: 'video.mp4'
physics_engine: "physx"

env:
  numEnvs: ${resolve_default:4096,${...num_envs}}
  numActions: 6
  numLatent: 0 # (8, 3, 3)
  numHistorySamples: 1 # t-1, t-4, t-7
  numHistoryStep: 1 # t-1 -> t-4 -> t-7
  envSpacing: 3. # [m]
  enableJoystick: False
  onlyForwards: False
  startAtLevel: -1

  terrain:
    terrainType: plane # none, plane, or trimesh
    staticFriction: 1.0 # [-]
    dynamicFriction: 1.0 # [-]
    restitution: 0. # [-]
    # rough terrain only:
    curriculum: true
    maxInitMapLevel: 0
    mapLength: 8.
    mapWidth: 8.
    numLevels: 10
    numTerrains: 20

    # tri mesh only:
    slopeTreshold: 0.2

    terrainProportions: # Proportions for each kind of terrain
      pyramid_sloped_upwards: 0.0
      pyramid_sloped_downwards: 0.0
      pyramid_stairs_upwards: 0.0
      pyramid_stairs_downwards: 0.0
      pyramid_stairs_downwards_small: 0.0
      discrete_obstacles: 0.0
      stepping_stones: 0.0
      random_uniform: 1.0
      flat: 0.0
      rough_sloped_upwards: 0.00
      rough_sloped_downwards: 0.00
      rough_stairs_upwards: 0.0
      rough_stairs_downwards: 0.0
      gap: 0.0

  baseInitState:
    pos: [0.0, 0.0, 0.4] # x,y,z [m]
    rot: [0.0, 0.0, 0.0, 1] # x,y,z,w [quat]
    vLinear: [0.0, 0.0, 0.0] # x,y,z [m/s]
    vAngular: [0.0, 0.0, 0.0] # x,y,z [rad/s]
  
  randomCommandVelocityRanges:
    # train
    linear_x: [0.0, 0.0] # min max [m/s]
    linear_y: [0.0, 0.0] # min max [m/s]
    yaw: [-0.0, 0.0] # min max [rad/s]

  control:
    # PD Drive parameters:
    stiffness: 4.0 # [N*m/rad]
    damping: 0.2 # [N*m*s/rad]
    # action scale: target angle = actionScale * action + defaultAngle
    actionScale: 0.5
    # decimation: Number of control action updates @ sim DT per policy DT
    decimation: 4

  defaultJointAngles: # = target angles when action = 0.0
    FL_HAA: 0.0 # [rad]
    FL_HFE: 0.916 # [rad]
    FL_KFE: -1.616 # [rad]

    FR_HAA: 0.0 # [rad]
    FR_HFE: 0.916 # [rad]
    FR_KFE: -1.616 # [rad]

  urdfAsset:
    file: "bolt_description/urdf/bolt_description.urdf"
    baseName: base_link
    footName: FOOT
    shinName: LOWER
    kneeName: UPPER
    imuTF:  # TODO croux 
      p:
        x: 0.00213
        y: 0
        z: -0.0115
      r:
        x: 0
        y: 0
        z: 0
        w: 1
    collapseFixedJoints: True
    fixBaseLink: false
    defaultDofDriveMode: 4 # see GymDofDriveModeFlags (0 is none, 1 is pos tgt, 2 is vel tgt, 4 effort)
    flip_visual_attachments: False
    armature: 0.00036207 # i.e motor inertia at joint level

  learn:
    allowShinContacts: True
    allowKneeContacts: False
  
    # Scales of rewards
    rewMult: 1.0
    terminalReward: 0.0
    linearPositionXYRewardScale: 0.0
    linearVelocityXYRewardScale: 1.0
    angularPositionZRewardScale: 0.0
    angularVelocityZRewardScale: 0.5
    torqueRewardScale: -0.0
    feetAirTimeRewardScale: 0.0 #Â 3.0 (as reward)
    actionRateRewardScale: -0.0
    footTwoContactRewardScale: 0.0 # 1.0 (as reward)

    # Misc quantities for rewards
    linearPositionXYRewardDelta: 0.25
    linearVelocityXYRewardDelta: 0.25
    angularPositionZRewardDelta: 0.25
    angularVelocityZRewardDelta: 0.25
    feetAirTimeRewardTarget: 0.30

    # Constraints
    enableConstraints: "cat"  # "none", "cat"
    constraints_CaT:
      survivalBonus: 0.0
      feetAirTimeConstraint: 0.2
      tauConstraint: 0.95
      minPConstraint: 0.0
      softPConstraint: 0.25
      useSoftPCurriculum: True
      linTrackingConstraint: 1000
      angTrackingConstraint: 1000

    limits:
      torque: 3.0
      acc: 800.0
      vel: 16.0
      action_rate: 100.0
      base_orientation: 0.2
      foot_contact_force: 25.0
      HFE: 0.5
      HAA: 0.3
      base_height_min: 100

    # Other
    flatTerrainThreshold: 0.001
    vel_deadzone: 0.01
    base_height_target: 0.34
    gait_period: 0.3

    # observations
    observe:
      base_lin_vel: false
      base_ang_vel: true
      commands: true
      misc: true
      heights: false
      phases: false
      imu: false
      base_lin_pos: false
      base_ang_pos: false
    measured_points_step: 0.08
    measured_points_x: [-3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    measured_points_y: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5]
    phases_freq: 2.0

    # normalization
    linearVelocityScale: 2.0
    angularVelocityScale: 0.25
    dofPositionScale: 1.0
    dofVelocityScale: 0.05
    heightMeasurementScale: 5.0
    imuAccelerationScale: 0.1
    linearPositionScale: 1.0
    angularPositionScale: 1.0

    # noise
    addNoise: true
    noiseLevel: 1.0

    ## JOINTS
    ### dof position randomization
    initDofPositionOffset: 0.5
    dofPositionNoise: [0.08, 0.02]

    ### dof velocity randomization
    initDofVelocityOffset: 0.1
    dofVelocityNoise: [0.01, 0.2]

    ## BASE
    ### base linear position randomization
    initXYoffset: 1.0
    linearPositionNoise: [0.01, 0.005]  

    ### base angular position randomization  
    initYawOffset: 0.1
    initPitchOffset: 0.1
    initRollOffset: 0.1
    angularPositionNoise: [0.0, 0.0]

    ### base linear velocity randomization
    linearVelocityNoise: [0.0, 0.0]

    ### base angular velocity randomization
    angularVelocityNoise: [0.1, 0.1]

    ### Accelerometer
    linearAccelerationNoise: [0.0, 0.0]
    gravityNoise: [0.1, 0.05]

    ## INERTIA
    inertialMassNoise: 0.1
    inertialCoMNoise: 0.1
    inertialMatrixNoise: 0.1

    ## LATENCY

    ## OTHER
    heightMeasurementNoise: 0.01

    ## FRICTION
    randomizeFriction: true
    frictionRange: [-0.2, 1.5]

    ## PUSHES
    pushRobots: true
    pushInterval_s: 8

    # episode length in seconds
    episodeLength_s: 10

  # viewer cam:
  viewer:
    refEnv: 0
    pos: [0, 0, 5] # [m]
    lookat: [1., 1, 4.5] # [m]

  # set to True if you use camera sensors in the environment
  enableCameraSensors: True

sim:
  dt: 0.005
  substeps: 1
  up_axis: "z"
  use_gpu_pipeline: ${eq:${...pipeline},"gpu"}
  gravity: [0.0, 0.0, -9.81]
  physx:
    num_threads: ${....num_threads}
    solver_type: 0 # ${....solver_type}
    use_gpu: ${contains:"cuda",${....sim_device}} # set to False to run on CPU
    num_position_iterations: 4
    num_velocity_iterations: 1
    contact_offset: 0.02
    rest_offset: 0.0
    bounce_threshold_velocity: 0.2
    max_depenetration_velocity: 100.0
    default_buffer_size_multiplier: 5.0
    max_gpu_contact_pairs: 33554432 # 8388608 = 8*1024*1024
    num_subscenes: ${....num_subscenes}
    contact_collection: 1 # 0: CC_NEVER (don't collect contact info), 1: CC_LAST_SUBSTEP (collect only contacts on last substep), 2: CC_ALL_SUBSTEPS (broken - do not use!)

task:
  randomize: False
